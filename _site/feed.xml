<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-09-15T16:09:08+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">DSM Blogs</title><subtitle>This is a blog about Data Science and Machine Learning. I write about all the things I learn in this domain. I also share my knowledge with you.</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2024/09/15/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2024-09-15T15:08:10+05:30</published><updated>2024-09-15T15:08:10+05:30</updated><id>http://localhost:4000/jekyll/update/2024/09/15/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/09/15/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">Hashing and Hash Functions</title><link href="http://localhost:4000/data/structures/2022/03/22/Hashing-and-Hash-Functions.html" rel="alternate" type="text/html" title="Hashing and Hash Functions" /><published>2022-03-22T15:08:10+05:30</published><updated>2022-03-22T15:08:10+05:30</updated><id>http://localhost:4000/data/structures/2022/03/22/Hashing-and-Hash-Functions</id><content type="html" xml:base="http://localhost:4000/data/structures/2022/03/22/Hashing-and-Hash-Functions.html"><![CDATA[<h1 id="introduction">Introduction</h1>

<p>Let’s talk hashing and hash tables. Array + Linked List advantages.</p>

<p><code class="language-plaintext highlighter-rouge">Hash Table</code> is a data structure which organizes data using <code class="language-plaintext highlighter-rouge">hash functions</code> in order to support quick insertion and search.</p>

<h1 id="hashing">Hashing</h1>

<p>In hashing, we convert a value/num/string into key index using hash function. The idea is to uniformly distribute the key to the array.</p>

<p><code class="language-plaintext highlighter-rouge">Hash_func(value/int/string) = key/index</code></p>

<p><code class="language-plaintext highlighter-rouge">arr[key/index] = value/int/string</code></p>

<p>When we insert a key-value pair in a hash table, we store the key along with its value.</p>

<p>Properties of good hash function: -</p>

<ol>
  <li>Makes use of all info provided by key</li>
  <li>Uniformly distributes output across table</li>
  <li>Maps similar keys to very different hash values</li>
  <li>Uses only very fast operations.</li>
</ol>

<h1 id="avoiding-collision">Avoiding Collision</h1>

<p>It’s very hard to create a perfect hashing function. Rarely or when we use a bad hashing function, it gives same key for 2 different values. Such case is known as Collision.</p>

<p>To avoid collision we apply different techniques, as explained below:</p>

<h2 id="1-separate-chaining">1. Separate chaining</h2>

<p>In this we use a map of type vector, hence we simply push the next value at the key.</p>

<p>Example →</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">index</span> <span class="o">=</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">map</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>Complexity:</p>

<p>Insertion takes O(1) and search takes O(k), k = size of linked list.</p>

<p><strong>Open addressing</strong> based algorithms. In these algorithms we find the next empty space.</p>

<h2 id="2-linear-probing">2. Linear Probing</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">not</span> <span class="n">empty</span><span class="o">:</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">size</span>
	<span class="n">i</span><span class="o">++</span>
</code></pre></div></div>

<p><a href="https://leetcode.com/explore/learn/card/hash-table/182/practical-applications/1139/">Implementation of Hash Set with Linear probing</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyHashSet</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="n">static</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000005</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

<span class="nc">MyHashSet</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">memset</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">void</span> <span class="nf">add</span><span class="p">(</span><span class="nb">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="nb">hash</span> <span class="n">function</span>
    <span class="nb">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="o">//</span> <span class="n">linear</span> <span class="n">probing</span>
    <span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="nf">while</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">//</span> <span class="n">store</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="nf">remove</span><span class="p">(</span><span class="nb">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="nf">while</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="o">//</span> <span class="n">remove</span> <span class="n">only</span> <span class="k">if</span> <span class="n">contains</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">size</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="nb">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="o">//</span> <span class="n">move</span> <span class="n">till</span> <span class="n">empty</span> <span class="n">space</span>
    <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="nf">while</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="o">//</span> <span class="n">contains</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
        
        <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><a href="https://leetcode.com/explore/learn/card/hash-table/182/practical-applications/1140/">Hash Map Implementation with 2 arrays and Linear probing</a></li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyHashMap</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1000005</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    
    <span class="n">MyHashMap</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// already present</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            
            <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">value</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="c1">// contains</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> 
                <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="n">indx</span><span class="p">];</span>
            
            <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span> <span class="n">size</span><span class="p">;</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="c1">// remove only if contains</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">value</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">indx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indx</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">size</span><span class="p">;</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="complexity">Complexity:</h3>

<p>Search and insert both takes O(n), n = size of table</p>

<h2 id="3-quadratic-probing">3. Quadratic Probing</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="n">not</span> <span class="n">empty</span><span class="o">:</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span>
	<span class="n">i</span><span class="o">++</span>
</code></pre></div></div>

<h2 id="4-double-hashing">4. Double hashing</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">index</span> <span class="o">=</span> <span class="n">hashfunc</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">index2</span> <span class="o">=</span> <span class="n">hashfunc2</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">while</span> <span class="n">not</span> <span class="n">empty</span><span class="o">:</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">index2</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span>
	<span class="n">i</span><span class="o">++</span>
</code></pre></div></div>

<p>Practically we use separate chaining with height-balanced BST.</p>

<h3 id="complexity-">Complexity:-</h3>

<p>The average time complexity of both insertion and search is still <code class="language-plaintext highlighter-rouge">O(1)</code>. And the time complexity in the worst case is <code class="language-plaintext highlighter-rouge">O(logN)</code> for both insertion and search by using height-balanced BST (at each index, using vector). It is a trade-off between insertion and search.</p>]]></content><author><name></name></author><category term="Data" /><category term="structures" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>